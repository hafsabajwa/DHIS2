"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setUpServiceWorker = setUpServiceWorker;

var _workboxPrecaching = require("workbox-precaching");

var _workboxRouting = require("workbox-routing");

var _workboxStrategies = require("workbox-strategies");

var _constants = require("../lib/constants");

var _recordingMode = require("./recording-mode");

var _utils = require("./utils");

function setUpServiceWorker() {
  const pwaEnabled = process.env.REACT_APP_DHIS2_APP_PWA_ENABLED === 'true';

  if (!pwaEnabled) {
    // Install 'killswitch' service worker and refresh page to clear
    // rogue service workers. App should then unregister SW
    (0, _utils.setUpKillSwitchServiceWorker)();
    return;
  } // Misc setup
  // Disable verbose logs
  // TODO: control with env var


  self.__WB_DISABLE_DEV_LOGS = true; // Globals (Note: global state resets each time SW goes idle)
  // Tracks recording states for multiple clients to handle multiple windows
  // recording simultaneously

  self.clientRecordingStates = {}; // Local constants

  const PRODUCTION_ENV = process.env.NODE_ENV === 'production';
  const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$'); // Workbox routes
  // Only precache in production mode to enable easier app development.
  // In development, static assets are handled by 'network first' strategy
  // and will be kept up-to-date.

  if (PRODUCTION_ENV) {
    // Precache all of the assets generated by your build process.
    // Their URLs are injected into the manifest variable below.
    // This variable must be present somewhere in your service worker file,
    // even if you decide not to use precaching. See https://cra.link/PWA.
    // Includes all built assets and index.html
    const precacheManifest = self.__WB_MANIFEST || []; // Extract index.html from the manifest to precache, then route
    // in a custom way

    const indexHtmlManifestEntry = precacheManifest.find(({
      url
    }) => url.endsWith('index.html'));
    (0, _workboxPrecaching.precache)([indexHtmlManifestEntry]); // Custom strategy for handling app navigation, specifically to allow
    // navigations to redirect to the login page while online if the
    // user is unauthenticated. Fixes showing the app shell login dialog
    // in production if a user is online and unauthenticated.
    // Uses app-shell style routing to route navigations to index.html.

    const navigationRouteMatcher = ({
      request,
      url
    }) => {
      // If this isn't a navigation, skip.
      if (request.mode !== 'navigate') {
        return false;
      } // If this is a URL that starts with /_, skip.


      if (url.pathname.startsWith('/_')) {
        return false;
      } // If this looks like a URL for a resource, because it contains
      // a file extension, skip (unless it's index.html)


      if (fileExtensionRegexp.test(url.pathname) && !url.pathname.endsWith('index.html')) {
        return false;
      } // Return true to signal that we want to use the handler.


      return true;
    };

    const indexUrl = process.env.PUBLIC_URL + '/index.html';

    const navigationRouteHandler = ({
      request
    }) => {
      return fetch(request).then(response => {
        if (response.type === 'opaqueredirect') {
          // It's sending a redirect to the login page. Return
          // that to the client
          return response;
        } // Otherwise return precached index.html


        return (0, _workboxPrecaching.matchPrecache)(indexUrl);
      }).catch(() => {
        // Request failed (maybe offline). Return cached response
        return (0, _workboxPrecaching.matchPrecache)(indexUrl);
      });
    };

    (0, _workboxRouting.registerRoute)(navigationRouteMatcher, navigationRouteHandler); // Handle the rest of files in the manifest

    const restOfManifest = precacheManifest.filter(e => e !== indexHtmlManifestEntry);
    (0, _workboxPrecaching.precacheAndRoute)(restOfManifest); // Similar to above; manifest injection from `workbox-build`
    // Precaches all assets in the shell's build folder except in `static`
    // (which CRA's workbox-webpack-plugin handle smartly).
    // Additional files to precache can be added using the
    // `additionalManifestEntries` option in d2.config.js; see the docs and
    // 'injectPrecacheManifest.js' in the CLI package.
    // '[]' fallback prevents an error when switching pwa enabled to disabled

    (0, _workboxPrecaching.precacheAndRoute)(self.__WB_BUILD_MANIFEST || []);
  } // Request handler during recording mode: ALL requests are cached
  // Handling routing: https://developers.google.com/web/tools/workbox/modules/workbox-routing#matching_and_handling_in_routes


  (0, _workboxRouting.registerRoute)(_recordingMode.shouldRequestBeRecorded, _recordingMode.handleRecordedRequest); // If not recording, fall through to default caching strategies for app
  // shell:
  // SWR strategy for static assets that can't be precached.
  // (Skip in development environments)

  (0, _workboxRouting.registerRoute)(({
    url
  }) => PRODUCTION_ENV && (0, _utils.urlMeetsAppShellCachingCriteria)(url) && fileExtensionRegexp.test(url.pathname), new _workboxStrategies.StaleWhileRevalidate({
    cacheName: 'other-assets'
  })); // Network-first caching by default

  (0, _workboxRouting.registerRoute)(({
    url
  }) => (0, _utils.urlMeetsAppShellCachingCriteria)(url), new _workboxStrategies.NetworkFirst({
    cacheName: 'app-shell'
  })); // Strategy for all other requests: try cache if network fails,
  // but don't add anything to cache

  class NetworkAndTryCache extends _workboxStrategies.Strategy {
    _handle(request, handler) {
      return handler.fetch(request).catch(fetchErr => {
        // handler.cacheMatch doesn't work b/c it doesn't check all caches
        return caches.match(request).then(res => {
          // If not found in cache, throw original fetchErr
          // (if there's a cache err, that will be returned)
          if (!res) {
            throw fetchErr;
          }

          return res;
        });
      });
    }

  } // Use fallback strategy as default


  (0, _workboxRouting.setDefaultHandler)(new NetworkAndTryCache()); // Service Worker event handlers

  self.addEventListener('message', event => {
    if (!event.data) {
      return;
    }

    if (event.data.type === _constants.swMsgs.getClientsInfo) {
      (0, _utils.getClientsInfo)(event);
    } // Can be used upon first SW activation


    if (event.data.type === _constants.swMsgs.claimClients) {
      (0, _utils.claimClients)();
    } // This allows the web app to trigger skipWaiting via
    // registration.waiting.postMessage({type: 'SKIP_WAITING'})


    if (event.data.type === _constants.swMsgs.skipWaiting) {
      self.skipWaiting();
    }

    if (event.data.type === _constants.swMsgs.startRecording) {
      (0, _recordingMode.startRecording)(event);
    }

    if (event.data.type === _constants.swMsgs.completeRecording) {
      (0, _recordingMode.completeRecording)(event.source.id); // same as FetchEvent.clientId
    }
  }); // Open DB on activation

  self.addEventListener('activate', event => {
    event.waitUntil((0, _utils.createDB)().then(_utils.removeUnusedCaches));
  });
}